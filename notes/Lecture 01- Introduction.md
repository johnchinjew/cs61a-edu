# Lecture 01: Introduction
> All computing begins with representing information, specifying logic to process it, and designing abstractions that manage the complexity of that logic.

## Primitives

- Evaluate in one step

## Non-primitive expressions

- Require work to evaluate

## Statements & Expressions

- Expressions: compute/evaluate to values
- Statements: carry out some action

## Evaluating Nested Expressions

- Expression tree

## Functions (or call expressions)

- Functions encapsulate logic that manipulates data

```python3
add ( 2 , 3 ) # operator ( operand , operand )
```

1. Evaluate the operator
2. Evaluate the operands
3. Apply the operator (function) to the operands (arguments)

## Objects
- An object seamlessly bundles together data and the logic that manipulates that data, in a way that manages the complexity of both.

## Errors
> Incremental testing, modular design, precise assumptions, and teamwork
1. Test incrementally: write small modular pieces which can be easily tested
2. Isolate errors: trace error to the smallest fragment of code
3.  Check your assumptions: Know your assumptions, then verify assumptions
4. Consult others